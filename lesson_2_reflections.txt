What happens when you initialize a repository? Why do you need to do it?

    Within the folder that you run 'init' from, Git creates a new hidden called '.git' containing a 
    config file, description file, a file that points to the current HEAD, and a bunch folders 
    containing files that Git needs for operation.

    We need to initialize a repository in this way (or via the GitHub Desktop, or in other ways 
    still) to begin using Git to track and store changes (commits) to all the files in this 
    repository.



How is the staging area different from the working directory and the repository? What value do you 
think it offers?

    The staging area offers me a place to gather files I wish to commit to the repository, which is 
    useful since there could be a bunch of stuff in my working directory that I never intend to 
    commit as part of the project, like local configuration files or raw and half-edited image 
    files.



How can you use the staging area to make sure you have one commit per logical change?

    Comparing the staging area to the working directory (with 'git diff') reveals which files in the
    working directory have been changed (and exactly what changes made, pretty cool!). This help us 
    ensure that - when we're happy with the logical change we've made by tweaking as many files as 
    we needed to - we add and commit all files associated with the logical change.



What are some situations when branches would be helpful in keeping your history organized? How would
branches help?

    For creating new features that we're not yet sure we want to include in the main project. For 
    allowing dev collaboration without risking the intergity of the initial code base. For 
    experimentation and destructive testing.  